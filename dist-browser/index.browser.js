!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.PQJS=t():e.PQJS=t()}(this,()=>(()=>{"use strict";var e={442:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.initFalcon=async function(){return n||(r?n:new Promise((e,t)=>{if("function"==typeof window.FalconModule){const i={locateFile:e=>e.endsWith(".wasm")?"../../sig/falcon/dist-browser/falcon_wrapper.wasm":e};window.FalconModule(i).then(i=>{r=i,o().then(()=>e(n)).catch(t)}).catch(t)}else{const i=document.createElement("script");i.src="../../sig/falcon/dist-browser/falcon_wrapper.js",i.onload=async()=>{try{const t={locateFile:e=>e.endsWith(".wasm")?"../../sig/falcon/dist-browser/falcon_wrapper.wasm":e};r=await window.FalconModule(t),await o(),e(n)}catch(e){t(e)}},i.onerror=()=>{t(new Error("Failed to load Falcon WASM module"))},document.head.appendChild(i)}}))},t.cleanupFalcon=function(){r=null,n=null};let r=null,n=null;async function i(e){if(!r)throw new Error("Module not initialized. Call initFalcon() first.");const t=r;console.log(`[Debug] Available Falcon functions for ${e}:`,Object.keys(t).filter(e=>e.includes("falcon")));const n=`_init_falcon_${e}`;if(t[n]){console.log(`[Debug] Calling ${n}`);const r=t[n]();console.log(`[Debug] Initialization result: ${r}`),0!==r&&console.warn(`[Debug] Falcon ${e} initialization failed with status code: ${r}, proceeding anyway`)}else console.warn(`[Debug] Initialization function ${n} not found, proceeding without initialization`);const i=t[`_falcon_${e}_get_public_key_length`](),o=t[`_falcon_${e}_get_secret_key_length`](),l=t[`_falcon_${e}_get_signature_length`]();function a(e,t){if(0!==e)throw new Error(`${t} failed with OQS status code: ${e}`)}function c(e,r){if(!e||!r)return null;if(!t.HEAPU8)throw new Error("WASM memory not initialized");if(e+r>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to read ${r} bytes at ${e}, but HEAPU8 length is ${t.HEAPU8.length}`);return new Uint8Array(t.HEAPU8.slice(e,e+r))}function s(e,r){if(r&&e){if(!t.HEAPU8)throw new Error("HEAPU8 is undefined before write");if(r+e.length>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to write ${e.length} bytes at ${r}, but HEAPU8 length is ${t.HEAPU8.length}`);t.HEAPU8.set(e,r)}}return console.log(`[Debug] Falcon ${e} lengths - pub: ${i}, sec: ${o}, sig: ${l}`),{generateKeypair(){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const r=t._malloc(i);if(!r)throw new Error("Failed to allocate memory for public key");const n=t._malloc(o);if(!n)throw new Error("Failed to allocate memory for secret key");try{if(!r||!n)throw new Error("Failed to allocate memory for keypair");a(t[`_falcon_${e}_keypair`](r,n),"Keypair generation");const l=c(r,i),s=c(n,o);if(!l||!s)throw new Error("Failed to copy keypair data");return{publicKey:l,secretKey:s}}finally{r&&t._free(r),n&&t._free(n)}},sign(r,n){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const i="string"==typeof r?(new TextEncoder).encode(r):r;if(n.length!==o)throw new Error(`Invalid secret key length. Expected ${o}, got ${n.length}`);const f=t._malloc(i.length);if(!f)throw new Error("Failed to allocate message buffer");s(i,f);const u=t._malloc(n.length);if(!u)throw new Error("Failed to allocate secret key buffer");s(n,u);const h=t._malloc(l);if(!h)throw new Error("Failed to allocate signature buffer");const w=t._malloc(4);if(!w)throw new Error("Failed to allocate signature length buffer");t.HEAPU32[w>>2]=l;try{a(t[`_falcon_${e}_sign`](h,w,f,i.length,u),"Signing");const r=t.HEAPU32[w>>2];if(r>l)throw new Error(`Signature length ${r} exceeds maximum ${l}`);const n=c(h,r);if(!n)throw new Error("Failed to copy signature data");return n}finally{t._free(f),t._free(u),t._free(h),t._free(w)}},verify(r,n,i){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const o="string"==typeof r?(new TextEncoder).encode(r):r,l=t._malloc(o.length);if(!l)throw new Error("Failed to allocate message buffer");s(o,l);const a=t._malloc(n.length);if(!a)throw new Error("Failed to allocate signature buffer");s(n,a);const c=t._malloc(i.length);if(!c)throw new Error("Failed to allocate public key buffer");s(i,c);try{return 0===t[`_falcon_${e}_verify`](l,o.length,a,n.length,c)}finally{t._free(l),t._free(a),t._free(c)}},getPublicKeyLength:()=>i,getSecretKeyLength:()=>o,getSignatureLength:()=>l}}async function o(){try{const e=await i(512),t=await i(1024);n={falcon_512:e,falcon_1024:t}}catch(e){throw console.error("[Debug] Error creating wrappers:",e),e}}},657:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.initSphincs=async function(){return n||(r?n:new Promise((e,t)=>{if("function"==typeof window.SphincsModule){const i={locateFile:e=>e.endsWith(".wasm")?"../../sig/sphincs/dist-browser/sphincs_wrapper.wasm":e};window.SphincsModule(i).then(i=>{r=i,o().then(()=>e(n)).catch(t)}).catch(t)}else{const i=document.createElement("script");i.src="../../sig/sphincs/dist-browser/sphincs_wrapper.js",i.onload=async()=>{try{const t={locateFile:e=>e.endsWith(".wasm")?"../../sig/sphincs/dist-browser/sphincs_wrapper.wasm":e},i=await window.SphincsModule(t);r=i,await o(),e(n)}catch(e){t(e)}},i.onerror=()=>t(new Error("Failed to load SPHINCS+ wrapper script")),document.head.appendChild(i)}}))},t.cleanupSphincs=function(){r=null,n=null};let r=null,n=null;async function i(e){if(!r)throw new Error("Module not initialized. Call initSphincs() first.");const t=r,n=t[`_init_sphincs_sha2_${e}f_simple`]();0!==n&&console.warn(`SPHINCS+ ${e} initialization failed with status code: ${n}, proceeding anyway`);const i=t[`_sphincs_sha2_${e}f_simple_get_public_key_length`](),o=t[`_sphincs_sha2_${e}f_simple_get_secret_key_length`](),l=t[`_sphincs_sha2_${e}f_simple_get_signature_length`]();function a(e,t){if(0!==e)throw new Error(`${t} failed with OQS status code: ${e}`)}function c(e,r){if(!e||!r)return null;if(!t.HEAPU8)throw new Error("WASM memory not initialized");if(e+r>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to read ${r} bytes at ${e}, but HEAPU8 length is ${t.HEAPU8.length}`);return new Uint8Array(t.HEAPU8.slice(e,e+r))}function s(e,r){if(r&&e){if(!t.HEAPU8)throw new Error("HEAPU8 is undefined before write");if(r+e.length>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to write ${e.length} bytes at ${r}, but HEAPU8 length is ${t.HEAPU8.length}`);t.HEAPU8.set(e,r)}}return{generateKeypair(){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const r=t._malloc(i);if(!r)throw new Error("Failed to allocate memory for public key");const n=t._malloc(o);if(!n)throw new Error("Failed to allocate memory for secret key");try{if(!r||!n)throw new Error("Failed to allocate memory for keypair");a(t[`_sphincs_sha2_${e}f_simple_keypair`](r,n),"Keypair generation");const l=c(r,i),s=c(n,o);if(!l||!s)throw new Error("Failed to copy keypair data");return{publicKey:l,secretKey:s}}finally{r&&t._free(r),n&&t._free(n)}},sign(r,n){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const i="string"==typeof r?(new TextEncoder).encode(r):r;if(n.length!==o)throw new Error(`Invalid secret key length. Expected ${o}, got ${n.length}`);const f=t._malloc(i.length);if(!f)throw new Error("Failed to allocate message buffer");s(i,f);const u=t._malloc(n.length);if(!u)throw new Error("Failed to allocate secret key buffer");s(n,u);const h=t._malloc(l);if(!h)throw new Error("Failed to allocate signature buffer");const w=t._malloc(4);if(!w)throw new Error("Failed to allocate signature length buffer");t.HEAPU32[w>>2]=l;try{a(t[`_sphincs_sha2_${e}f_simple_sign`](h,w,f,i.length,u),"Signing");const r=t.HEAPU32[w>>2];if(r>l)throw new Error(`Signature length ${r} exceeds maximum ${l}`);const n=c(h,r);if(!n)throw new Error("Failed to copy signature data");return n}finally{t._free(f),t._free(u),t._free(h),t._free(w)}},verify(r,n,i){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const o="string"==typeof r?(new TextEncoder).encode(r):r,l=t._malloc(o.length);if(!l)throw new Error("Failed to allocate message buffer");s(o,l);const a=t._malloc(n.length);if(!a)throw new Error("Failed to allocate signature buffer");s(n,a);const c=t._malloc(i.length);if(!c)throw new Error("Failed to allocate public key buffer");s(i,c);try{return 0===t[`_sphincs_sha2_${e}f_simple_verify`](l,o.length,a,n.length,c)}finally{t._free(l),t._free(a),t._free(c)}},getPublicKeyLength:()=>i,getSecretKeyLength:()=>o,getSignatureLength:()=>l}}async function o(){n={};const e=[128,192,256];for(const t of e)try{n[`sphincs_sha2_${t}f_simple`]=await i(t)}catch(e){console.warn(`Failed to create wrapper for SPHINCS+ ${t}:`,e)}}},768:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.initDilithium=async function(){return n||(r?n:new Promise((e,t)=>{if("function"==typeof window.DilithiumModule){const i={locateFile:e=>e.endsWith(".wasm")?"../../sig/dilithium/dist-browser/dilithium_wrapper.wasm":e};window.DilithiumModule(i).then(i=>{r=i,o().then(()=>e(n)).catch(t)}).catch(t)}else{const i=document.createElement("script");i.src="../../sig/dilithium/dist-browser/dilithium_wrapper.js",i.onload=async()=>{try{const t={locateFile:e=>e.endsWith(".wasm")?"../../sig/dilithium/dist-browser/dilithium_wrapper.wasm":e};r=await window.DilithiumModule(t),await o(),e(n)}catch(e){t(e)}},i.onerror=()=>{t(new Error("Failed to load Dilithium WASM module"))},document.head.appendChild(i)}}))},t.cleanupDilithium=function(){if(r)try{"function"==typeof r._free_dilithium_variants?r._free_dilithium_variants():console.warn("[Debug] _free_dilithium_variants not found in module")}catch(e){console.error("[Debug] Error during cleanup:",e)}r=null,n=null};let r=null,n=null;async function i(e){if(!r)throw new Error("Module not initialized. Call initDilithium() first.");const t=r;if(1!==t._init_dilithium_variants())throw new Error("Failed to initialize dilithium variants");const n=t[`_dilithium${e}_get_public_key_length`](),i=t[`_dilithium${e}_get_secret_key_length`](),o=t[`_dilithium${e}_get_signature_length`]();function l(e,t){if(0!==e)throw new Error(`${t} failed with OQS status code: ${e}`)}function a(e,r){if(!e||!r)return null;if(!t.HEAPU8)throw new Error("WASM memory not initialized");if(e+r>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to read ${r} bytes at ${e}, but HEAPU8 length is ${t.HEAPU8.length}`);return new Uint8Array(t.HEAPU8.slice(e,e+r))}function c(e,r){if(r&&e){if(!t.HEAPU8)throw new Error("HEAPU8 is undefined before write");if(r+e.length>t.HEAPU8.length)throw new Error(`Buffer overflow: trying to write ${e.length} bytes at ${r}, but HEAPU8 length is ${t.HEAPU8.length}`);t.HEAPU8.set(e,r)}}return{generateKeypair(){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const r=t._malloc(n);if(!r)throw new Error("Failed to allocate memory for public key");const o=t._malloc(i);if(!o)throw new Error("Failed to allocate memory for secret key");try{if(!r||!o)throw new Error("Failed to allocate memory for keypair");l(t[`_dilithium${e}_keypair`](r,o),"Keypair generation");const c=a(r,n),s=a(o,i);if(!c||!s)throw new Error("Failed to copy keypair data");return{publicKey:c,secretKey:s}}finally{r&&t._free(r),o&&t._free(o)}},sign(r,n){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const s="string"==typeof r?(new TextEncoder).encode(r):r;if(n.length!==i)throw new Error(`Invalid secret key length. Expected ${i}, got ${n.length}`);const f=t._malloc(s.length);if(!f)throw new Error("Failed to allocate message buffer");c(s,f);const u=t._malloc(n.length);if(!u)throw new Error("Failed to allocate secret key buffer");c(n,u);const h=t._malloc(o);if(!h)throw new Error("Failed to allocate signature buffer");const w=t._malloc(4);if(!w)throw new Error("Failed to allocate signature length buffer");t.HEAPU32[w>>2]=o;try{l(t[`_dilithium${e}_sign`](h,w,f,s.length,u),"Signing");const r=t.HEAPU32[w>>2];if(r>o)throw new Error(`Signature length ${r} exceeds maximum ${o}`);const n=a(h,r);if(!n)throw new Error("Failed to copy signature data");return n}finally{t._free(f),t._free(u),t._free(h),t._free(w)}},verify(r,n,i){if(!t.HEAPU8)throw new Error("WASM memory not initialized");const o="string"==typeof r?(new TextEncoder).encode(r):r,l=t._malloc(o.length);if(!l)throw new Error("Failed to allocate message buffer");c(o,l);const a=t._malloc(n.length);if(!a)throw new Error("Failed to allocate signature buffer");c(n,a);const s=t._malloc(i.length);if(!s)throw new Error("Failed to allocate public key buffer");c(i,s);try{return 0===t[`_dilithium${e}_verify`](l,o.length,a,n.length,s)}finally{t._free(l),t._free(a),t._free(s)}},getPublicKeyLength:()=>n,getSecretKeyLength:()=>i,getSignatureLength:()=>o}}async function o(){try{const e=await i(2),t=await i(3),r=await i(5);n={dilithium2:e,dilithium3:t,dilithium5:r}}catch(e){throw console.error("[Debug] Error creating wrappers:",e),e}}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}var n={};return(()=>{var e=n;Object.defineProperty(e,"__esModule",{value:!0}),e.cleanupMcEliece=e.cleanupFrodokem=e.cleanupMlkem=e.cleanupSphincs=e.initMcEliece=e.initFrodokem=e.initMlkem=e.initSphincs=e.initFalcon=e.initDilithium=void 0,e.createPQ=l,e.cleanupPQ=a,e.cleanupPQFull=function(){a()},e.createSignatures=async function(){return(await l()).signatures},e.createKEM=async function(){return(await l()).kem},e.createKEMFull=async function(){return(await l()).kem},e.cleanupSignatures=function(){(0,t.cleanupDilithium)(),(0,i.cleanupFalcon)(),(0,o.cleanupSphincs)()},e.cleanupKEM=function(){},e.cleanupKEMFull=function(){};const t=r(768),i=r(442),o=r(657);async function l(){try{const e=await(0,t.initDilithium)(),r=await(0,i.initFalcon)();return{signatures:{dilithium:e,sphincs:await(0,o.initSphincs)(),falcon:r},kem:{mlkem:{},frodokem:{},mceliece:{}}}}catch(e){throw console.error("Failed to initialize PQ library:",e),e}}function a(){(0,t.cleanupDilithium)(),(0,i.cleanupFalcon)(),(0,o.cleanupSphincs)()}e.initDilithium=t.initDilithium,e.initFalcon=i.initFalcon,e.initSphincs=o.initSphincs,e.initMlkem=()=>Promise.resolve({}),e.initFrodokem=()=>Promise.resolve({}),e.initMcEliece=()=>Promise.resolve({}),e.cleanupSphincs=o.cleanupSphincs,e.cleanupMlkem=()=>{},e.cleanupFrodokem=()=>{},e.cleanupMcEliece=()=>{}})(),n})());